知识点：

1.内联函数：将函数代码直接载入调用者的代码段中，不用进入堆栈区重新分配内存;类似于C的宏定义，内联函数不能递归;

2.引用变量：已定义变量的别名，类似于 使用取值运算符后的指针，但必须在声明时初始化; 右值引用(&&)

3.继承：将特性从一个类传递给另一个类的语言特性;

4.基类的引用可以指向派生类的对象，无需进行强制类型转换;

5.方法setf()返回调用它之前有效的所有格式化设置;
  ios_base::fmtflags是存储这种信息所需要的数据类型名称;
  可以使用如下代码来实现保存和还原格式化设置：
  ios_base::fmtflags initial;
  initial = os.setf(ios_base::fixed); 	//备份初始状态
  ...
  os.setf(initial); 	//还原初始状态

6.传递类对象参数的标准方式是按引用传递;

7.默认参数：当函数调用中省略了实参时自动使用的一个值;
  设置方法：通过函数原型将值赋给原型中的参数;
  设置规则：从右向左添加默认值，实参从左向右依次被赋给相应的形参;

8.在使用函数重载时，编译器将类型引用和类型本身视为同一个特征标,而将是否带关键字const、以及左值引用、右值引用视为不同特征标;

9.特征标(参数列表)决定函数是否可以重载;

10.名称修饰：C++编译器会根据函数原型中指定的形参对每个函数名进行加密，从而实现函数重载;

11.编译器在选择原型时，非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本;

12.具体化：使用具体类型的函数定义，而不是通用描述; 分为隐式实例化、显式实例化和显式具体化;

13.模板 例：template <typename/*or class*/ AnyType>
            void fun(AnyType a, AnyType b);
   隐式实例化 例：template <typename/*or class*/ AnyType>
   		  void fun(AnyType a, AnyType b);

   两者区别：在代码中包含函数模板本身并不会生成函数定义，函数调用导致编译器使用模板为特定类型生成函数定义，此时得到模板实例;而隐式实例化是函数定义;

   显式实例化 例：template void fun<int>(int, int);
   显式具体化 例：template <> void fun<int>(int &, int &); or
   		  template <> void fun(int &, int &);

   两者区别：以上声明的意思是：不要使用模板来生成函数定义，而应使用专门为int类型显式第定义函数定义，显式具体化声明在关键字template后面包含<>,而显式实例化没有;

   注意：在同一个文件中不允许使用同一种类型的显式实例和显式具体化！！
