知识点：

1. 包含（组合或者层次化）：类的成员本身是另一个类的对象;

2. 接口和实现：使用公有继承时，类可以继承接口，可能还有实现（基类的纯虚函数提
供接口，但不提供实现）。获得接口是is-a关系的组成部分。而使用组合，类可以
获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。

3. 可以用一个参数调用的构造函数实现从参数类型到类类型的隐式转换函数，但这
不是一个好注意！可以使用explicit关闭隐式转换。

4. 当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，
而不是它们在初始化列表中的顺序。

5. 私有继承：基类的公有成员和保护成员都将成为派生类的私有成员;

6. 使用包含时将使用对象名来调用方法，而使用私有继承时将使用类名和作用域解析
运算符来调用方法;

7. 通过使用基类的强制类型转换来转换派生类的this指针可以调用基类的私有成员;
	例：return (const string &) *this; 该语句将派生类对象转换为
		string类的对象，通过return语句达到访问基类私有成员的目的。

8. 使用包含还是私有继承：
	包含：优点是具体，简单，易于理解;缺点是提供的特性较少;
	私有继承：优点是提供的特性较多;但缺点是较抽象，难于理解。

	通常，应使用包含来建立has-a关系;如果新类需要访问原有类的保护成员，
	或需要重新定义虚函数，则应使用私有继承。

9. 保护继承：基类的公有成员和保护成员都将称为派生类的保护成员;

10. using声明：可以在派生类的公有部分用using声明来指出派生类可以使用的特定基类
成员;

11. C++模板提供参数化类型，即能够将类型名作为参数传递给接收方来建立类或函数;

12. 使用指针栈的方法之一是：让调用程序提供一个指针数组，其中每个指针都指向不同的字符串;

13. 由于模板不是函数，它们不能单独编译，模板必须与特定的实例化请求一起使用;
为此，最简单的方法是将所有模板信息放在一个头文件中.

14. 可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值;

15. 模板类的非模板友元，例： public: friend void counts(); 
				or friend void counts(HasFriend<T> &);

    模板类的约束模版友元，例：在类定义前声明：template <typename T> void counts();
    			在类中再次声明：friend void counts<TT>();

    模板类的非约束模板友元，例：template <typename T>
    				class ManyFriend
				{
					...;
					template <typename C,typename D> friend void show2(C &, D &);
				};

16. 模板别名：  typedef std::array<double, 12> arrd; 等价于
		using arrd = std::array<double, 12>;
    还可以这样： using arrtype = std::array<T, 12>;(C++11)

17. 包含中使用成员类的公有方法时可以直接用对象调用；
    私有继承中使用基类公有成员和保护成员时要使用类名和作用域解析运算符调用.
