1. 基类的公有成员称为派生类的公有成员。基类的保护成员称为派生类的保护成员。基类的私有成员被继承，但不能直接访问.

2. 构造函数、析构函数、友元和赋值运算符.

3. 如果返回类型为void，仍可以使用单个赋值，但不能使用连锁赋值.

4. 创建--构造函数：基类->派生类;
   删除--析构函数：派生类->基类.

5. 可以为空，但必须存在.

6. 如果不是虚方法，则派生类的方法将会覆盖基类的方法;仅当派生类没有重新定义方法或使用作用域解析运算符时，才会调用基类方法.
	如果是虚方法，则根据指针或引用指向的对象类型来确定使用哪个方法.

7. 构造函数中使用了new.

8. 可以将派生类对象的地址赋给基类指针;但只有通过显式类型转换，才可以将基类对象的地址赋给派生类指针，但这样的指针不一定安全.

9. 派生类对象赋给基类对象时将使用基类的赋值运算符，只有定义了转换运算符或使用基类为参数的赋值运算符时，
	才可以将基类对象赋给派生类对象.

10. 因为派生类的引用或指针可以在不显式转换的情况下赋给基类引用或指针.

11. 因为基类的复制构造函数将会把创建一个临时基类对象，并对派生类对象进行强制类型转换.

12. 因为按值传递需要创建临时副本，对于类来说，会增加很大的系统开销.

13. a. Corporation::ph->head();
    b. Corporation::ph->head();

14. 基类中的area使用了virtual,但派生类中的area没有使用，House中的area()覆盖了Kitchen版本.
