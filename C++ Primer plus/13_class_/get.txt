知识点：

1. 类继承：从已有的类派生出新的类，派生类继承了原有类的特征，并可以进行扩展和修改.

2. 派生类的声明格式：
	class RatedPlayer/*派生类*/ : public/*公有派生*/ TableTennisPlayer /*基类名*/
	{
	}

3. 派生类需要添加自己的构造函数，可以添加额外的数据成员和成员函数;

4. 派生类的对象不能直接访问基类的私有成员，只能通过基类方法进行访问，派生类构造函数必须使用基类构造函数;

5. 基类和派生类之间的关系：①派生类可以使用基类的公有方法;
			   ②基类指针可以在不进行显式类型转换的情况下指向派生类对象;
			   ③基类引用可以在不进行显式转换的情况下引用派生类对象.

6. 程序将根据对象类型来确定使用哪一个方法（基类和派生类都有的但进行不同操作的方法）;

7. 对于虚方法（使用virtual修饰）：如果不是虚方法，程序将根据 引用类型 或 指针类型 选择方法；
				  如果是虚方法，程序将根据引用或指针 指向的对象 的类型来选择方法.

8. 成员初始化列表法的作用（新增）：派生类构造函数可以用此来初始化基类的私有数据.

9. 在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法.

10. 在公有继承中，可以创建一个指向基类对象的指针数组，用它来指向基类对象或者是派生类对象，这是多态的一种体现形式.

11. 静态联编：在编译时进行联编;
    动态联编：在程序运行时进行联编.

    编译器对虚函数使用动态联编.

12. 通常应该给基类（就算不用作基类）提供一个虚析构函数，以保证它的派生类对象在消亡时先调用自己的析构函数，再调用基类的析构函数.

13. 重新定义继承的方法并不是重载，如果在派生类中重新定义函数，将不是使用同名的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何.

14. 保护成员：用关键字protected修饰，该成员可以被派生类对象直接访问，但对于外部，它也属于基类的私有数据，但最好采用私有访问控制，并通过基类方法使派生类能够访问基类数据.

15. ABC（抽象基类）：至少包含一个纯虚函数的基类.纯虚函数声明的结尾处为=0.
	例：virtual double Area() const = 0; or void Move(int nx, ny) = 0;

16. 当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素.
	对于析构函数：这是自动完成的;
	对于构造函数：这是通过在初始化成员列表中调用基类的复制构造函数来完成的;
	对于赋值运算符：这是通过使用作用域解析运算符显式地调用基类的赋值运算符来完成的.

17. 友元函数：因为友元函数不是类成员函数，所以不能继承，但是可以在派生类的友元函数中使用强制类型转换来调用基类的友元函数.
		（如赋值运算符和<<运算符）

-------------ABC总结--------------

1. 构造函数不能是虚函数, 但可以有定义;

2. 抽象基类最好将析构函数声明为虚函数;

//3. 可以将所有派生类中都会用到的数据声明为保护成员(protected);

4. 派生类中会用到的成员函数在基类中声明为虚函数;

5. 抽象基类中不能定义纯虚函数;
