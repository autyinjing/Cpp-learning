总结：

1. 通过类继承可以扩展和修改类，重复使用类库，从而提高了C++代码的可重用性;

2. 派生类和基类的关系（公有继承）：派生类是一种基类，它拥有自己的私有成员，而且可以使用基类的所有公有成员，这种关系称为is-a关系.

3. 由于派生类和基类的特殊关系，指向派生类对象的指针和引用可以在不显式强制转换的情况下指向基类对象，但反过来不行.
	因此，可以声明一个指向派生类的指针数组来访问派生类和基类的对象，这是多态的一种体现.

4. 多态公有继承：①在派生类中重新定义基类的方法可以让基类和派生类分别使用自己的方法;
		 ②如果方法不是虚方法（virtual修饰），程序将根据指针或者引用的类型选择方法;
		  如果方法是虚方法，程序将根据指针或引用 指向的对象的类型 来选择方法.

5. 对于派生类需要注意的：①需要定义自己的构造函数，如果构造函数中使用了动态内存分配，则还需定义复制构造函数、
				析构函数和赋值运算符;
			 ②最好在基类中定义一个虚析构函数，这样在派生类对象消亡时，程序首先调用派生类的析构函数，
			 	然后调用基类的析构函数;
			 ③在派生类中重新定义基类的方法时，若基类的方法没有声明为虚方法，则新定义的方法将覆盖
			 	基类中的方法，无论特征标如何，这不是函数重载.
			 ④派生类的构造函数中必须使用成员列表初始化来初始化基类部分的数据成员，当然，可以调用
			 	基类的构造函数来初始化基类的成员部分.

6. 访问控制（protected修饰保护成员）：对于外部，保护成员和私有成员相似;对于派生类，保护成员和公有成员相似.

7. 抽象基类（ABC）：至少包含一个纯虚函数（原型结尾处为=0），不能创建对象，只能用作基类.
			如果要设计类继承层次，则只能将那些不会被用作基类的类设计为具体的类.

8. 如果将一个对象赋给一个基本类型的变量（或者将派生类对象赋给基类对象），则编译器将处理相同部分的赋值;
	如果提供了显式的赋值运算符，则将使用该运算符.

9. 可以通过强制类型转换将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数.
