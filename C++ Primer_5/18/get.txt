第十八章：用于大型程序的工具

知识点积累：

1. 如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块当中，并且在析构函数内部得到处理；

2. 异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁；

3. 如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类放在前面，而将继承链最顶端的类放在后面；

4. 关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline，也可以不写；

5. 未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束时才销毁；如果一个头文件定义了
        未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体；

6. 当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间；

7. 我们在每个实参类（以及实参类的基类）所属的命名空间中搜寻候选函数时，这些命名空间中所有与被调用函数同名的函数都将被添加
        到候选集当中，即使其中某些函数在调用语句处不可见也是如此；

8. 对于using指示来说，引入一个与已有函数形参列表完全相同的函数并不会产生错误，只要我们指明调用的是命名空间中的函数版本还是
        当前作用域的版本即可；

9. 如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本；

10. 默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象，
        我们可以通过使用虚继承来使派生类中只包含该类的一个子对象；

11. 虚继承的对象构造与析构顺序：（构造）间接虚基类-->直接虚基类-->非虚基类的间接基类-->直接非虚基类-->派生类，析构与此相反；

C++11新特性：noexcept说明、noexcept运算符、内联命名空间、继承构造函数
