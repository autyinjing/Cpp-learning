第十三章：拷贝控制

知识点积累：

1. 当指向一个对象的引用或指针离开作用域时，析构函数不会执行；

2. 析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的；在整个销毁过程中，析构函数体是作为成员
        销毁步骤之外的另一部分而进行的；

3. 对于析构函数已经删除的类型，不能定义该类型的变量或释放指向该类型动态分配的对象的指针；

4. 如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的；

5. 希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的；

6. 如果一个类定义了自己的swap，那么算法将使用类自定义版本，否则使用标准库定义的版本；类型特定的swap版本匹配程度会优于std中的版本；

7. 在赋值运算符中使用拷贝并交换的技术可以安全地处理自赋值的情况，并且代码简洁易读；

C++11新特性：=delete、=default、移动构造函数、右值引用、move、移动赋值运算符、noexcept、移动迭代器、引用限定符
