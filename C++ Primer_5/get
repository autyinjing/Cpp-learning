        
    C++的基础学习告一段落了，现在将学习过程中积累下来的重点、难点、易忘记的知识点收集一下

第二章：变量和基本类型

  1. 如果我们使用列表初始化且初始值存在丢失信息的风险（高精度向低精度转换），则编译器将报错；

  2. extern语句如果包含初始值就不再是声明，而是定义；在函数体内部，如果试图初始化一个由extern标记的变量将引发错误；

  3. void *可以存放任意对象的地址，但不能直接操作void *所指的对象，也不能确定在该对象上能做哪些操作；

  4. 默认状态下，const对象仅在文件内有效；

  5. 声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化；

  6. auto让编译器通过初始值来推算变量的类型，所以auto定义的变量必须有初始值；

  7. decltype的作用是选择并返回操作数的数据类型，而不实际计算表达式的值，如果给变量加上一层或多层括号（变量变为表达式），则得到的永远是该表达式类型的引用；

  8. 对于不知道具体类型的变量或者函数返回值，使用auto和decltype可以避免出现类型不符而导致的错误；


第三章：字符串、向量和数组

  1. 如果使用等号（=）初始化一个变量，则执行拷贝初始化；如果不使用等号，则执行的是直接初始化；

  2. size_type是标准库中一种特定的无符号类型，具体与机器实现相关，可以用auto或者decltype来推断并定义变量；

  3. 当把string对象和字符字面值混在一条语句中使用时，必须确保每个加法运算符两侧至少有一个是string类型，因为字符字面值没有定义加法运算符；

  4. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号例进行列表初始化，而不能放在圆括号里；

  5. 范围for语句体内不应改变其所遍历序列的大小；

  6. vector对象的类型总是包含着元素的类型；如vector<int>::size_type;而非vector::size_type;

  7. 所有标准库容器的迭代器都定义了==和！=，但是它们中大多数都没有定义<运算符，所以在比较迭代器时只能用==和！=；

  8. string提供了一个c_str成员函数，它返回一个C风格的字符串（指针）；

  9. 使用范围for语句处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型；


第四章：表达式

  1. 当一个对象被用作右值的时候，用的是对象的值；当用作左值时，用的是对象的身份（内存中的位置）；

  2. 如果m%n不等于0，则它的符号和m相同；除了-m导致溢出的情况，(-m)/n和m/(-n)都等于-(m/n)；

  3. 在sizeof的运算对象中解引用无效指针是一种安全的行为，因为指针并没有被真正使用，sizeof不需要真的解引用指针也能知道它所指对象的类型；

  4. 算术转换一般规则：①整型提升；
                       ②有符号到无符号（两者所占空间一样大）；
                       ③低精度到高精度；
                       ④赋值语句的右侧到左侧；

  5. 只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性将引发错误；


第五章：语句

  1. goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内；

  2. 异常，指存在于运行时的反常行为，这些行为超出了函数正常功能范围。典型的异常包括失去数据库连接以及遇到意外输入等；

  3. 异常安全的代码：在异常发生期间执行了“清理”工作的程序；


第六章：函数

  1. 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素，拷贝后原始列表和副本共享元素；

  2. initializer_list对象中的元素永远是常量值，我们无法改变；

  3. 调用一个返回引用的函数得到的是左值，其他返回类型得到右值；

  4. C++11规定函数可以返回花括号包围的值列表；

  5. 声明一个返回数组指针的函数，例：
                普通：int (*func(para_list))[dimension];
                尾置返回类型：auto func(int i)->int(*)[10] (C++11)

  6. 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载；在传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数；

  7. 在C++中，名字查找发生在类型检查之前；

  8. constexpr函数是指能用于常量表达式的函数，函数的返回类型及所有的形参类型都得是字面值类型，且函数体中只能有一条return语句；

  9. decltype作用于某个函数时，它返回函数类型而非指针类型，我们需要显示地加上*来表明我们需要返回指针；


第七章：类

  1. 只有当类没有声明任何构造函数时，编译器会自动生成默认构造函数；然而如果我们需要默认行为，可以通过在参数列表后面加上=default来要求编译器生成构造函数；

  2. 定义类时，如果使用struct关键字，则定义在第一个访问说明符之前的成员都是public的；如果使用class，则是private的；

  3. 友元声明只能出现在类定义的内部，但在类内出现的具体位置不限，友元不是类成员，所以不受所在区域访问控制级别的约束；

  4. 定义在类内部的成员函数都是自动inline的；

  5. 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员；

  6. 如果类成员使用了外层作用域的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字；

  7. 如果类成员是const、引用、或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值；

  8. 编译器只会自动地执行一步的类型转换；

  9. 当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用，编译器将不会在自动转换过程中使用该构造函数；


第八章：IO类

  1. 不能拷贝或是对IO对象赋值，读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的；

  2. 交互式系统通常应该关联输入流和输出流，这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来；


第九章：顺序容器

  1. 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同；但如果传递迭代器参数来拷贝一个范围时，只要能将要拷贝的元素转换为容器的元素类型即可；

  2. 赋值相关的运算会导致指向左边容器内部的迭代器、引用和指针失效，而swap操作将内容交换将不会；（array和string除外）

  3. 交换两个容器内容的操作保证会很快，因为元素本身并未交换，swap只交换了两个容器内部的数据结构，从而导致在swap后，指向容器的迭代器、引用和指针都不会失效，它们仍然指向swap操作之前所指向的那些元素，只不过交换之后这些元素已经属于不同的容器了；

  4. 新标准库既提供成员版本的swap，也提供非成员版本的swap，统一使用非成员版本是一个好习惯；

  5. 关系运算符左右两边的对象必须是相同类型的容器，必须保存相同类型的元素，而且元素类型必须定义了相应的关系运算符；

  6. const修饰的对象调用begin()、end()和调用cbegin()、cend()的返回值类型相同，都是const_iterator；


第十章：泛型算法

  1. 算法永远也不会改变底层容器的大小，算法可能改变容器中保存元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素（链表版本除外）;

  2. 如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void；

  3. 捕获列表只用于局部非static变量，lambda可以直接使用局部static变量的它所在函数之外声明的名字；

  4. 使用算法操作流迭代器时，如果操作的是文件，则在执行算法后，对应绑定文件的类对象已经将文件指针移至算法操作后的位置，若要再次读取，需要关闭文件后重新打开；

  5. 流不是容器类，不能执行容器的诸如push_back()等操作，所以只能使用算法操作流迭代器从而操作流；


第十一章：关联容器

  1. 对于有序容器map、multimap、set、multiset，关键字类型必须定义元素比较方法，默认为"<"，也可以提供自定义的比较方法；

  2. 当使用迭代器遍历一个map、multimap、set或者multiset时，迭代器按关键字升序遍历元素；

  3. 当对一个map进行下标操作时，会获得一个mapped_type对象，它是一个左值；但当解引用一个map迭代器时，会得到一个value_type对象；

  4. 无序容器将具有一个特定哈希值的所有元素都保存在相同的桶中，如果允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中；

  5. 关联容器的迭代器都是双向的；


第十二章：动态内存与智能指针

  1. 接受指针参数的智能指针构造函数是explicit的，我们不能将一个内置指针隐式转换为一个只能指针，必须使用直接初始化形式；

  2. get用来将指针的访问权限传递给代码，只有在确定代码不会delete指针的情况下，才能使用get；特别地，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值；

  3. 类的前向声明仅仅告诉编译器该名称是一个类，是一个不完全类型，所以在该类的定义之前只能：定义指向这种类型的指针或引用，声明（不能定义）以不完全类型作为参数或者返回类型的函数；

  4. 静态内存用来保存局部static对象、类static成员以及定义在任何函数之外的变量；栈内存用来保存定义在函数内的非static对象；堆内存用来保存动态分配的对象；

  5. 开始一个程序设计的一种好方法是列出程序的操作，了解需要哪些操作会帮助我们分析出需要什么样的数据结构；在真正实现成员之前先编写程序使用这个类，可以看到类是否具有我们需要的操作；


第十三章：拷贝控制

  1. 当指向一个对象的引用或指针离开作用域时，析构函数不会执行；

  2. 析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的；在整个销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的；

  3. 对于析构函数已经删除的类型，不能定义该类型的变量或释放指向该类型动态分配的对象的指针；

  4. 如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的；

  5. 希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的；

  6. 如果一个类定义了自己的swap，那么算法将使用类自定义的版本，否则使用标准库定义的版本；类型特定的swap版本匹配程度会优于std中的版本；

  7. 在赋值运算符中使用拷贝并交换的技术可以安全地处理自赋值的情况，并且代码简洁易读；


第十四章：重载运算与类型转换

  1. 某些运算符重载之后无法保留求值顺序和/或短路求值属性，所以不应该重载它们.如（&& || ,）

  2. 如果存在唯一一种逻辑可靠的<定义,则应该考虑为这个类定义<运算符;如果类同时还包含==,则当且仅当<的定义和==产生的结果一致时才定义<运算符;


第十五章：面向对象程序设计

  1. 当我们使用基类的指针或引用调用一个虚函数时将发生动态绑定；

  2. 基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此；

  3. 每个类控制它自己的成员的初始化过程；

  4. 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义；

  5. 基类中的虚函数在派生类中隐含地也是一个虚函数；当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配；

  6. 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中受保护成员没有任何访问特权；

  7. 基类中的成员访问说明符决定了基类对象及派生类对该成员的访问权限；派生类的派生列表访问说明符决定了派生类对基类的public成员和protected成员的访问权限；

  8. 对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；

  9. 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本；


第十六章：模板与泛型编程

  1. 非类型模板参数的模板实参必须是常量表达式；

  2. 如果用户比较两个未指向相同数组的指针，则代码的行为是未定义的；模板程序应尽量减少对实参类型的要求；

  3. 只有当我们实例化出模板的一个特定版本时，编译器才会生成代码；类模板的成员函数只有当我们使用时才实例化；

  4. 一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型的名字用作其模板实参；相反的，我们通常将模板的参数当做被使用模板的实参；

  5. 类模板的成员函数具有和模板相同的模板参数，因此，定义在类模板之外的成员函数就必须以关键字template开始，后接模板参数列表；

  6. 当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样；

  7. 为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数；

  8. C++语言假定通过作用域运算符访问的名字不是类型；如果我们希望使用一个模板类型参数的类型成员，就必须通过关键字typename显式告诉编译器该名字是一个类型；

  9. 当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供参数列表；

  10. 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换；

  11. 一个模板类型参数可以用作多个函数形参的类型，但是传递给这些形参的实参必须具有相同的类型；如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数；


第十七章：标准库特殊设施

  1. string的下标编号习惯与bitset恰好相反：string中下标最大的字符（最右字符）用来初始化bitset中的低位（下标为0的二进制位）；

  2. 一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static；


第十八章：用于大型程序的工具

  1. 如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块中，并且在析构函数内部得到处理；

  2. 异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁；

  3. 如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类放在前面，而将继承链最顶端的类放在后面；

  4. 关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline，也可以不写；

  5. 未命名的命名空间中定义的变量拥有静态声明周期：它们在第一次使用前创建，并且直到程序结束时才销毁；如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体；

  6. 当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间；

  7. 我们在每个实参类（以及实参类的基类）所属的命名空间中搜寻候选函数时，这些命名空间中所有与被调用函数同名的函数都将被添加到候选集当中，即使其中某些函数在调用语句处不可见也是如此；

  8. 对于using指示来说，引入一个与已有参数列表完全相同的函数并不会产生错误，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可；

  9. 如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本；

  10. 默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象，我们可以通过使用虚继承来使派生类中只包含该类的一个子对象；

  11. 虚继承的对象构造与析构顺序：（构造）间接虚基类-->直接虚基类-->非虚基类的间接基类-->直接非虚基类-->派生类，析构与此相反；
