第十五章：面向对象程序设计

知识点积累：

1. 当我们使用基类的指针或引用调用一个虚函数时将发生动态绑定；

2. 基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此；

3. 每个类控制它自己的成员初始化过程；

4. 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义；

5. 基类中的虚函数在派生类中隐含地也是一个虚函数；当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配；

6. 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中受保护成员没有任何访问特权；

7. 基类中的成员访问说明符决定了基类对象及派生类对该成员的访问权限；派生类的派生列表访问说明符决定了派生类对基类的public成员
        和protected成员的访问权限；
        
8. 对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；

9. 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本；

C++11新特性：override、final、继承的构造函数.
