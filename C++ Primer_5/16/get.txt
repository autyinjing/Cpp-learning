第十六章：模板与泛型编程

知识点积累：

1. 非类型模板参数的模板实参必须是常量表达式；

2. 如果用户比较两个未指向相同数组的指针，则代码的行为是未定义的；模板程序应尽量减少对实参类型的要求；

3. 只有当我们实例化出模板的一个特定版本时，编译器才会生成代码；类模板的成员函数只有当我们使用时才实例化；

4. 一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型的名字用作其模板实参；相反的，我们通常将模板的参数
        当做被使用模板的实参；

5. 类模板的成员函数具有和模板相同的模板参数，因此，定义在类模板之外的成员函数就必须以关键字template开始，后接模板参数列表；

6. 当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的的实参一样；

7. 为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数；

8. C++语言假定通过作用域运算符访问的名字不是类型；如果我们希望使用一个模板类型参数的类型成员，就必须通过关键字typename
        显式告诉编译器该名字是一个类型；

9. 当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表；

10. 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换；

11. 一个模板类型参数可以用作多个函数形参的类型，但是传递给这些形参的实参必须具有相同的类型；如果希望允许对函数实参进行
        正常的类型转换，我们可以将函数模板定义为两个类型参数；

C++11新特性：将模板类型参数声明为友元、定义类模板的类型别名、函数模板的默认实参
